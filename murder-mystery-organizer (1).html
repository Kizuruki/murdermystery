<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Murder Mystery Organizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,300&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-bg: #1a0f0a;
            --secondary-bg: #2d1810;
            --accent-gold: #d4af37;
            --accent-crimson: #8b0000;
            --text-light: #f5e6d3;
            --text-muted: #9d8570;
            --border-color: #4a3428;
            --card-bg: #231610;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 100%);
            color: var(--text-light);
            min-height: 100vh;
            padding: 2rem;
            background-attachment: fixed;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,.1) 2px, rgba(0,0,0,.1) 4px),
                radial-gradient(circle at 20% 30%, rgba(212, 175, 55, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(139, 0, 0, 0.03) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 2rem;
        }

        .main-content {
            min-width: 0;
        }

        .sidebar {
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        .sidebar h2 {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--accent-gold);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            letter-spacing: 0.08em;
        }

        .sidebar-player {
            background: var(--secondary-bg);
            padding: 1rem;
            margin-bottom: 0.75rem;
            border-left: 3px solid var(--accent-gold);
            border-radius: 4px;
            font-size: 0.95rem;
        }

        .sidebar-player.dead {
            opacity: 0.5;
            border-left-color: var(--accent-crimson);
        }

        .sidebar-player strong {
            color: var(--accent-gold);
            font-family: 'Cinzel', serif;
            display: block;
            margin-bottom: 0.25rem;
        }

        .sidebar-player .role {
            font-weight: 600;
            color: var(--text-light);
        }

        .sidebar-player .preferences {
            font-size: 0.85rem;
            margin-top: 0.5rem;
            color: var(--text-muted);
        }

        .sidebar-player .objectives {
            font-size: 0.85rem;
            margin-top: 0.5rem;
            padding-left: 1.2rem;
        }

        .sidebar-player .objectives li {
            margin-bottom: 0.25rem;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 3.5rem;
            text-align: center;
            margin-bottom: 1rem;
            color: var(--accent-gold);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 0.1em;
            font-weight: 700;
        }

        .subtitle {
            text-align: center;
            font-size: 1.3rem;
            color: var(--text-muted);
            margin-bottom: 3rem;
            font-style: italic;
            letter-spacing: 0.05em;
        }

        .phase-indicator {
            text-align: center;
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            padding: 1rem;
            background: linear-gradient(90deg, transparent, var(--accent-crimson), transparent);
            margin-bottom: 2rem;
            border-top: 1px solid var(--accent-gold);
            border-bottom: 1px solid var(--accent-gold);
            letter-spacing: 0.15em;
        }

        .card {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
        }

        .card:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 8px 32px rgba(212, 175, 55, 0.2);
        }

        .card h2 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            margin-bottom: 1.5rem;
            color: var(--accent-gold);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            letter-spacing: 0.08em;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .character-checkbox {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .character-checkbox:hover {
            background: var(--border-color);
            border-color: var(--accent-gold);
        }

        .character-checkbox input[type="checkbox"] {
            margin-right: 0.75rem;
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent-gold);
        }

        .character-checkbox label {
            cursor: pointer;
            font-size: 1.1rem;
        }

        button {
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, var(--accent-crimson), #660000);
            color: var(--text-light);
            border: 2px solid var(--accent-gold);
            padding: 1rem 2.5rem;
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            font-weight: 600;
        }

        button:hover {
            background: linear-gradient(135deg, #660000, var(--accent-crimson));
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .button-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .role-assignment {
            background: var(--secondary-bg);
            padding: 1rem;
            border-left: 4px solid var(--accent-gold);
            margin-bottom: 0.75rem;
            border-radius: 4px;
            font-size: 1.1rem;
        }

        .role-assignment strong {
            color: var(--accent-gold);
            font-family: 'Cinzel', serif;
            letter-spacing: 0.05em;
        }

        .objectives-list {
            display: grid;
            gap: 1rem;
            margin-top: 1rem;
        }

        .objective-item {
            background: var(--secondary-bg);
            padding: 1rem;
            border-left: 3px solid var(--accent-crimson);
            border-radius: 4px;
        }

        select, input[type="number"] {
            background: var(--secondary-bg);
            color: var(--text-light);
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            border-radius: 4px;
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.1rem;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .action-grid {
            display: grid;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .action-row {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 1rem;
            align-items: center;
        }

        .action-label {
            font-family: 'Cinzel', serif;
            color: var(--accent-gold);
            font-size: 1.1rem;
            letter-spacing: 0.05em;
        }

        .feedback-section {
            background: var(--primary-bg);
            padding: 1.5rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            margin-bottom: 1rem;
        }

        .feedback-section h3 {
            font-family: 'Cinzel', serif;
            color: var(--accent-gold);
            margin-bottom: 1rem;
            font-size: 1.5rem;
            letter-spacing: 0.08em;
        }

        .feedback-item {
            background: var(--secondary-bg);
            padding: 1rem;
            margin-bottom: 0.75rem;
            border-left: 3px solid var(--accent-gold);
            border-radius: 4px;
            line-height: 1.6;
        }

        .player-status {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.9rem;
            font-family: 'Cinzel', serif;
            letter-spacing: 0.05em;
            margin-left: 0.5rem;
        }

        .alive { background: rgba(0, 128, 0, 0.3); border: 1px solid #00ff00; }
        .dead { background: rgba(139, 0, 0, 0.3); border: 1px solid var(--accent-crimson); }
        .good { background: rgba(212, 175, 55, 0.3); border: 1px solid var(--accent-gold); }
        .evil { background: rgba(139, 0, 0, 0.3); border: 1px solid var(--accent-crimson); }

        .vote-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .vote-item {
            background: var(--secondary-bg);
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .vote-item label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--accent-gold);
            font-family: 'Cinzel', serif;
        }

        .vote-results {
            background: var(--primary-bg);
            padding: 1.5rem;
            border-radius: 4px;
            border: 2px solid var(--accent-gold);
            margin-top: 1rem;
        }

        .vote-result-item {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem;
            background: var(--secondary-bg);
            margin-bottom: 0.5rem;
            border-radius: 4px;
            border-left: 3px solid var(--accent-crimson);
        }

        .points-section {
            background: var(--secondary-bg);
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
        }

        .points-input {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            align-items: center;
        }

        .leaderboard {
            background: linear-gradient(135deg, var(--accent-crimson), #660000);
            padding: 2rem;
            border-radius: 8px;
            border: 3px solid var(--accent-gold);
            margin-top: 2rem;
        }

        .leaderboard h2 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
            color: var(--accent-gold);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .podium {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .podium-place {
            background: var(--card-bg);
            padding: 2rem;
            border-radius: 8px;
            text-align: center;
            border: 2px solid var(--accent-gold);
        }

        .podium-place.first {
            order: 2;
            transform: scale(1.1);
            border-color: #ffd700;
            background: linear-gradient(135deg, var(--card-bg), #3d2a1a);
        }

        .podium-place.second {
            order: 1;
        }

        .podium-place.third {
            order: 3;
        }

        .medal {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .hidden {
            display: none;
        }

        .error {
            background: rgba(139, 0, 0, 0.3);
            border: 1px solid var(--accent-crimson);
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .success {
            background: rgba(0, 128, 0, 0.3);
            border: 1px solid #00ff00;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .container {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                position: static;
                max-height: none;
                order: -1;
            }
            
            .character-grid {
                grid-template-columns: 1fr;
            }
            
            .action-row {
                grid-template-columns: 1fr;
            }
            
            .podium {
                grid-template-columns: 1fr;
            }
            
            .podium-place.first {
                transform: none;
                order: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <h1>Murder Mystery</h1>
            <div class="subtitle">Organizer's Control Panel</div>

            <!-- Setup Phase -->
            <div id="setupPhase">
                <div class="card">
                    <h2>Character Selection</h2>
                    <div class="character-grid" id="characterGrid"></div>
                    <div class="button-group">
                        <button onclick="shuffleRoles()">Shuffle & Assign Roles</button>
                    </div>
                </div>
            </div>

            <!-- Role Assignment Display -->
            <div id="roleAssignmentPhase" class="hidden">
                <div class="card">
                    <h2>Role Assignments</h2>
                    <div id="roleAssignments"></div>
                    <div class="button-group">
                        <button onclick="assignObjectives()">Generate Objectives</button>
                    </div>
                </div>
            </div>

            <!-- Objectives Display -->
            <div id="objectivesPhase" class="hidden">
                <div class="card">
                    <h2>Character Objectives</h2>
                    <div id="objectivesDisplay"></div>
                    <div class="button-group">
                        <button onclick="startNightPhase()">Begin Night 1</button>
                    </div>
                </div>
            </div>

            <!-- Night Phase -->
            <div id="nightPhase" class="hidden">
                <div class="phase-indicator">Night Phase - Round <span id="nightRound">1</span></div>
                <div class="card">
                    <h2>Night Actions</h2>
                    <div class="action-grid" id="nightActions"></div>
                    <div class="button-group">
                        <button onclick="resolveNightActions()">Resolve Night Actions</button>
                    </div>
                </div>
            </div>

            <!-- Night Feedback -->
            <div id="nightFeedbackPhase" class="hidden">
                <div class="phase-indicator">Night Feedback</div>
                <div class="card">
                    <h2>Give Feedback to Players</h2>
                    <div id="nightFeedback"></div>
                    <div class="button-group">
                        <button onclick="startDayPhase()">Proceed to Day Phase</button>
                    </div>
                </div>
            </div>

            <!-- Day Phase -->
            <div id="dayPhase" class="hidden">
                <div class="phase-indicator">Day Phase - Round <span id="dayRound">1</span></div>
                <div class="card">
                    <h2>Voting</h2>
                    <div id="votingSection"></div>
                    <div class="button-group">
                        <button onclick="resolveVotes()">Count Votes</button>
                    </div>
                </div>
            </div>

            <!-- Vote Results -->
            <div id="voteResultsPhase" class="hidden">
                <div class="card">
                    <h2>Vote Results</h2>
                    <div id="voteResults"></div>
                    <div class="button-group">
                        <button onclick="checkWinCondition()">Continue</button>
                    </div>
                </div>
            </div>

            <!-- Game End -->
            <div id="gameEndPhase" class="hidden">
                <div class="card">
                    <h2>Game Over</h2>
                    <div id="gameEndMessage"></div>
                    <div class="button-group">
                        <button onclick="showPointsEntry()">Enter Points</button>
                    </div>
                </div>
            </div>

            <!-- Points Entry -->
            <div id="pointsEntryPhase" class="hidden">
                <div class="card">
                    <h2>Points Entry</h2>
                    <div id="pointsEntry"></div>
                    <div class="button-group">
                        <button onclick="calculateFinalScores()">Calculate Final Scores</button>
                    </div>
                </div>
            </div>

            <!-- Final Leaderboard -->
            <div id="leaderboardPhase" class="hidden">
                <div class="leaderboard">
                    <h2>Final Standings</h2>
                    <div class="podium" id="podium"></div>
                    <div id="fullLeaderboard"></div>
                    <div class="button-group">
                        <button onclick="playAgain()">Play Another Round</button>
                        <button onclick="wipeData()">Wipe All Data</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar hidden" id="sidebar">
            <h2>Players</h2>
            <div id="sidebarContent"></div>
        </div>
    </div>

    <script>
        const CHARACTERS = [
            { id: 1, name: "Lord/Lady Lochmara" },
            { id: 2, name: "Viscount/Viscountess Salem" },
            { id: 3, name: "Count/Countess Red-Violet" },
            { id: 4, name: "Baron/Baroness Cerulean" },
            { id: 5, name: "Prince/Princess Endeavour" },
            { id: 6, name: "Sir/Dame Robin" },
            { id: 7, name: "Steward/Stewardess Sangria" },
            { id: 8, name: "Servant Ecstasy" },
            { id: 9, name: "Prince Koamaru" },
            { id: 10, name: "Professor Haze" },
            { id: 11, name: "Colonel Crimson" },
            { id: 12, name: "Dr. Mysin" },
            { id: 13, name: "Duke/Duchess Scampi" },
            { id: 14, name: "Chaplain Atlantis" },
            { id: 15, name: "Mister/Mistress Rose" },
            { id: 16, name: "Groundskeeper Lemon" }
        ];

        const PREFERENCES = [
            "Cooking", "Drama", "Occult", "Art", "Music", "Martial Arts",
            "Painting", "Science", "Sports", "Gardening", "Games", "Opera",
            "Parties", "Jokes", "Animals", "Justice", "Violence", "Reading",
            "Gossip", "Socializing", "Solitude", "Academics", "Family", "Nature", "Money"
        ];

        // Role scaling based on player count
        function getRoleDistribution(numPlayers) {
            const distributions = {
                6: { evil: ["Murderer"], good: ["Doctor", "Judge"], civilians: 2 },
                7: { evil: ["Murderer", "Spy"], good: ["Doctor", "Judge", "Mayor", "Detective"], civilians: 2 },
                8: { evil: ["Murderer", "Spy"], good: ["Doctor", "Judge", "Mayor", "Detective"], civilians: 2 },
                9: { evil: ["Murderer", "Spy"], good: ["Doctor", "Judge", "Mayor", "Detective"], civilians: 3 },
                10: { evil: ["Murderer", "Spy"], good: ["Doctor", "Judge", "Mayor", "Detective", "Psychic"], civilians: 3 },
                11: { evil: ["Murderer", "Spy", "Witch"], good: ["Doctor", "Judge", "Mayor", "Detective", "Psychic"], civilians: 3 },
                12: { evil: ["Murderer", "Spy", "Witch"], good: ["Doctor", "Judge", "Mayor", "Detective", "Psychic", "Vigilante"], civilians: 3 },
                13: { evil: ["Murderer", "Spy", "Witch"], good: ["Doctor", "Judge", "Mayor", "Detective", "Psychic", "Vigilante", "Medium"], civilians: 3 },
                14: { evil: ["Murderer", "Assassin", "Spy", "Witch"], good: ["Doctor", "Judge", "Mayor", "Detective", "Psychic", "Vigilante", "Medium", "Coroner"], civilians: 2 },
                15: { evil: ["Murderer", "Assassin", "Spy", "Witch"], good: ["Doctor", "Judge", "Mayor", "Detective", "Psychic", "Vigilante", "Medium", "Coroner"], civilians: 3 },
                16: { evil: ["Murderer", "Assassin", "Spy", "Witch"], good: ["Doctor", "Judge", "Mayor", "Detective", "Psychic", "Vigilante", "Medium", "Coroner"], civilians: 4 }
            };
            
            return distributions[numPlayers] || null;
        }

        let gameState = {
            selectedCharacters: [],
            players: [],
            round: 1,
            mayorPenalty: false,
            cumulativeScores: {},
            gamesPlayed: 0,
            hiddenClues: [],
            deathLog: [], // Track all deaths and causes
            witchMimicHistory: [], // Track which roles Witch has mimicked
            witchCurrentMimic: null, // Current role Witch is mimicking
            witchMimicStartRound: null, // Round when Witch started mimicking
            assassinUsedKill: false, // Track if Assassin has used their kill
            vigilanteUsedKill: false, // Track if Vigilante has used their kill
            psychicCluesGiven: [], // Track clues given to Psychic
            roleBonuses: {} // Track role-specific bonus points eligibility
        };

        // Initialize character selection
        function initCharacterSelection() {
            const grid = document.getElementById('characterGrid');
            grid.innerHTML = '';
            
            CHARACTERS.forEach(char => {
                const div = document.createElement('div');
                div.className = 'character-checkbox';
                div.innerHTML = `
                    <input type="checkbox" id="char-${char.id}" value="${char.id}">
                    <label for="char-${char.id}">${char.name}</label>
                `;
                grid.appendChild(div);
            });
        }

        function shuffleRoles() {
            const selected = Array.from(document.querySelectorAll('#characterGrid input:checked'))
                .map(cb => parseInt(cb.value));
            
            if (selected.length < 6 || selected.length > 16) {
                alert('Please select 6-16 characters');
                return;
            }

            const distribution = getRoleDistribution(selected.length);
            if (!distribution) {
                alert('Invalid player count');
                return;
            }

            gameState.selectedCharacters = selected.map(id => 
                CHARACTERS.find(c => c.id === id)
            );

            // Build role array
            const allRoles = [
                ...distribution.evil,
                ...distribution.good,
                ...Array(distribution.civilians).fill("Civilian")
            ];
            
            // Shuffle roles
            for (let i = allRoles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allRoles[i], allRoles[j]] = [allRoles[j], allRoles[i]];
            }

            gameState.players = gameState.selectedCharacters.map((char, idx) => ({
                id: char.id,
                name: char.name,
                role: allRoles[idx],
                originalRole: allRoles[idx],
                alignment: (["Murderer", "Assassin", "Spy", "Witch"].includes(allRoles[idx])) ? "Evil" : "Good",
                alive: true,
                objectives: [],
                likes: [],
                dislikes: [],
                clues: [],
                votePower: allRoles[idx] === "Mayor" ? 2 : 1,
                judgeUses: allRoles[idx] === "Judge" ? 1 : 0,
                judgeUsedOn: [],
                doctorLastSaved: null, // Track who Doctor saved last
                vigilanteShot: false, // Track if Vigilante has shot
                assassinKilled: false // Track if Assassin has used kill
            }));

            // Reset game state trackers
            gameState.witchMimicHistory = [];
            gameState.witchCurrentMimic = null;
            gameState.witchMimicStartRound = null;
            gameState.assassinUsedKill = false;
            gameState.vigilanteUsedKill = false;
            gameState.psychicCluesGiven = [];
            gameState.deathLog = [];
            
            // Initialize role bonuses tracking
            gameState.roleBonuses = {};
            gameState.players.forEach(p => {
                gameState.roleBonuses[p.id] = {
                    doctorSaved: false,
                    detectiveCrime: false,
                    spyFoundLeaving: false,
                    judgeSavedInnocent: false
                };
            });

            // Generate clues
            generateClues();

            displayRoleAssignments();
        }

        function displayRoleAssignments() {
            const div = document.getElementById('roleAssignments');
            div.innerHTML = '';

            const murderer = gameState.players.find(p => p.role === "Murderer");
            const assassin = gameState.players.find(p => p.role === "Assassin");
            const spy = gameState.players.find(p => p.role === "Spy");
            const witch = gameState.players.find(p => p.role === "Witch");

            gameState.players.forEach(player => {
                const assignment = document.createElement('div');
                assignment.className = 'role-assignment';
                
                let extra = '';
                if (player.role === "Murderer") {
                    const teammates = [assassin, spy, witch].filter(p => p).map(p => `${p.name} (${p.role})`);
                    if (teammates.length > 0) {
                        extra = ` - Evil team: ${teammates.join(', ')}`;
                    }
                } else if (["Assassin", "Spy", "Witch"].includes(player.role)) {
                    const teammates = [murderer, assassin, spy, witch].filter(p => p && p.id !== player.id).map(p => `${p.name} (${p.role})`);
                    if (teammates.length > 0) {
                        extra = ` - Evil team: ${teammates.join(', ')}`;
                    }
                }
                
                assignment.innerHTML = `
                    <strong>${player.name} (#${player.id}):</strong> ${player.role}${extra}
                    <span class="player-status ${player.alignment.toLowerCase()}">${player.alignment}</span>
                `;
                div.appendChild(assignment);
            });

            // Add role descriptions
            const rolesPresent = [...new Set(gameState.players.map(p => p.role))];
            const descriptions = {
                "Murderer": "Kills one person per night (starting Night 1, except 7-player games skip Night 1). If Murderer dies, succession: Assassin → Spy → Witch.",
                "Assassin": "Gets ONE unblockable kill (cannot be saved by Doctor) to use any night. If both Murderer & Assassin die, succession begins.",
                "Spy": "Investigates one player per night (learns their ROLE). For 7-player games, Spy does not act Night 1. Becomes Murderer if original Murderer dies.",
                "Witch": "Mimics one role's ability each night (cannot repeat). Chooses role during night feedback, uses ability next day+night.",
                "Doctor": "Saves one person from murder per night. Cannot save self or same person twice in a row.",
                "Detective": "Investigates house each night: learns if target left house & who visited them.",
                "Judge": "1-time use: can spare someone from elimination. Sees vote totals after voting.",
                "Mayor": "Double voting power. If votes out innocent, power halved next round. Learns alignment of eliminated if they voted for them.",
                "Psychic": "Receives 1 random TRUE clue from hidden pool each night.",
                "Vigilante": "1-shot kill. If shoots Evil: Evil dies. If shoots Good: Vigilante dies, Good survives.",
                "Medium": "Learns the role of one dead person per night.",
                "Coroner": "Learns how each person died (murdered, voted out, vigilante kill, failed vigilante target)."
            };

            const descDiv = document.createElement('div');
            descDiv.style.marginTop = '2rem';
            descDiv.innerHTML = '<h3 style="color: var(--accent-gold); margin-bottom: 1rem;">Role Descriptions</h3>';
            rolesPresent.forEach(role => {
                if (descriptions[role]) {
                    descDiv.innerHTML += `<div class="feedback-item"><strong>${role}:</strong> ${descriptions[role]}</div>`;
                }
            });
            div.appendChild(descDiv);

            document.getElementById('setupPhase').classList.add('hidden');
            document.getElementById('roleAssignmentPhase').classList.remove('hidden');
        }

        function assignObjectives() {
            // Assign likes and dislikes
            gameState.players.forEach(player => {
                const prefs = [...PREFERENCES].sort(() => 0.5 - Math.random());
                player.likes = [prefs[0], prefs[1]];
                player.dislikes = [prefs[2], prefs[3]];
            });

            // Collect all preferences
            const allLikes = new Set();
            const allDislikes = new Set();
            
            gameState.players.forEach(player => {
                player.likes.forEach(pref => allLikes.add(pref));
                player.dislikes.forEach(pref => allDislikes.add(pref));
            });

            // Assign objectives
            gameState.players.forEach(player => {
                const objectives = [];
                
                objectives.push("Share to someone that you like/dislike something to complete their objective.");
                
                const possibleObjectives = [];
                
                allLikes.forEach(pref => {
                    if (!player.likes.includes(pref)) {
                        possibleObjectives.push(`Find someone who likes ${pref}.`);
                    }
                });
                
                allDislikes.forEach(pref => {
                    if (!player.dislikes.includes(pref)) {
                        possibleObjectives.push(`Find someone who dislikes ${pref}.`);
                    }
                });
                
                const shuffled = possibleObjectives.sort(() => 0.5 - Math.random());
                objectives.push(shuffled[0]);
                objectives.push(shuffled[1]);
                
                player.objectives = objectives;
            });

            displayObjectives();
            updateSidebar();
        }

        function generateClues() {
            const clueTemplates = {
                good: (name) => `${name} is a positive influence in the town.`,
                doctor: (name) => `${name} has knowledge that could be useful in emergencies.`,
                judge: (name) => `${name} has the power to change the outcome of a vote.`,
                secretive: (name) => `${name} might have a reason to act in secret.`,
                activeNight: (name) => `${name} is more active at night.`,
                mayor: (name) => `${name} has a deciding influence in discussions.`,
                shyDay: (name) => `${name} is shy in discussions.`,
                keepsToSelf: (name) => `${name} keeps to themselves at night.`
            };

            const isClueRealForPlayer = (player, clueType) => {
                switch(clueType) {
                    case 'good':
                        return player.alignment === "Good";
                    case 'doctor':
                        return player.role === "Doctor";
                    case 'judge':
                        return player.role === "Judge";
                    case 'secretive':
                        return ['Murderer', 'Assassin', 'Spy', 'Witch', 'Detective'].includes(player.role);
                    case 'activeNight':
                        return ['Murderer', 'Assassin', 'Spy', 'Witch', 'Doctor', 'Detective'].includes(player.role);
                    case 'mayor':
                        return player.role === "Mayor";
                    case 'shyDay':
                        return !['Mayor', 'Judge'].includes(player.role);
                    case 'keepsToSelf':
                        return ['Civilian', 'Mayor', 'Judge'].includes(player.role);
                    default:
                        return false;
                }
            };

            const allClueTypes = Object.keys(clueTemplates);
            
            // Assign 2 starting clues (1 real, 1 fake)
            gameState.players.forEach(player => {
                const startingClues = [];
                
                // Real clue
                let realClueFound = false;
                let attempts = 0;
                while (!realClueFound && attempts < 100) {
                    const randomClueType = allClueTypes[Math.floor(Math.random() * allClueTypes.length)];
                    const randomPerson = gameState.players[Math.floor(Math.random() * gameState.players.length)];
                    
                    if (isClueRealForPlayer(randomPerson, randomClueType)) {
                        startingClues.push({
                            text: clueTemplates[randomClueType](randomPerson.name),
                            isReal: true
                        });
                        realClueFound = true;
                    }
                    attempts++;
                }
                
                // Fake clue
                let fakeClueFound = false;
                attempts = 0;
                while (!fakeClueFound && attempts < 100) {
                    const randomClueType = allClueTypes[Math.floor(Math.random() * allClueTypes.length)];
                    const randomPerson = gameState.players[Math.floor(Math.random() * gameState.players.length)];
                    
                    if (!isClueRealForPlayer(randomPerson, randomClueType)) {
                        startingClues.push({
                            text: clueTemplates[randomClueType](randomPerson.name),
                            isReal: false
                        });
                        fakeClueFound = true;
                    }
                    attempts++;
                }
                
                player.startingClues = startingClues;
            });

            // Generate 2 hidden clues (real, not secretive)
            const validHiddenTypes = Object.keys(clueTemplates).filter(t => t !== 'secretive');
            const hiddenClues = [];
            const usedClues = new Set();
            
            let hiddenGenerated = 0;
            let attempts = 0;
            while (hiddenGenerated < 2 && attempts < 100) {
                const clueType = validHiddenTypes[Math.floor(Math.random() * validHiddenTypes.length)];
                const randomPerson = gameState.players[Math.floor(Math.random() * gameState.players.length)];
                
                if (isClueRealForPlayer(randomPerson, clueType)) {
                    const clueText = clueTemplates[clueType](randomPerson.name);
                    
                    if (!usedClues.has(clueText)) {
                        hiddenClues.push({
                            text: clueText,
                            isReal: true
                        });
                        usedClues.add(clueText);
                        hiddenGenerated++;
                    }
                }
                attempts++;
            }
            
            gameState.hiddenClues = hiddenClues;
        }

        function updateSidebar() {
            const sidebar = document.getElementById('sidebar');
            const content = document.getElementById('sidebarContent');
            
            if (gameState.players.length === 0) {
                sidebar.classList.add('hidden');
                return;
            }
            
            sidebar.classList.remove('hidden');
            content.innerHTML = '';
            
            gameState.players.forEach(player => {
                const div = document.createElement('div');
                div.className = `sidebar-player${player.alive ? '' : ' dead'}`;
                
                let roleDisplay = player.role;
                if (player.originalRole !== player.role) {
                    roleDisplay = `<span style="text-decoration: line-through; opacity: 0.6;">${player.originalRole}</span> → ${player.role}`;
                }
                
                div.innerHTML = `
                    <strong>${player.name} (#${player.id})</strong>
                    <div class="role">${roleDisplay} 
                        <span class="player-status ${player.alignment.toLowerCase()}">${player.alignment}</span>
                        ${!player.alive ? '<span class="player-status dead">Dead</span>' : ''}
                    </div>
                    <div class="preferences">
                        <strong>Likes:</strong> ${player.likes.join(', ')}<br>
                        <strong>Dislikes:</strong> ${player.dislikes.join(', ')}
                    </div>
                    <div class="preferences">
                        <strong>Clues:</strong><br>
                        ${(player.startingClues || []).map(clue => `
                            • ${clue.text} <span style="color: ${clue.isReal ? '#00ff00' : '#ff6b6b'}; font-size: 0.8rem;">(${clue.isReal ? 'Real' : 'Fake'})</span>
                        `).join('<br>')}
                    </div>
                    <div class="objectives">
                        <strong>Objectives:</strong>
                        <ol>
                            ${player.objectives.map(obj => `<li>${obj}</li>`).join('')}
                        </ol>
                    </div>
                `;
                content.appendChild(div);
            });

            // Hidden clues
            if (gameState.hiddenClues && gameState.hiddenClues.length > 0) {
                const hiddenDiv = document.createElement('div');
                hiddenDiv.className = 'sidebar-player';
                hiddenDiv.style.borderLeft = '3px solid var(--accent-crimson)';
                hiddenDiv.innerHTML = `
                    <strong>Hidden Clues</strong>
                    <div class="preferences" style="margin-top: 0.5rem;">
                        ${gameState.hiddenClues.map(clue => `
                            • ${clue.text} <span style="color: ${clue.isReal ? '#00ff00' : '#ff6b6b'}; font-size: 0.8rem;">(Real)</span>
                        `).join('<br>')}
                    </div>
                `;
                content.appendChild(hiddenDiv);
            }
        }

        function displayObjectives() {
            const div = document.getElementById('objectivesDisplay');
            div.innerHTML = '';

            gameState.players.forEach(player => {
                const section = document.createElement('div');
                section.className = 'objectives-list';
                section.innerHTML = `
                    <div class="objective-item">
                        <strong>${player.name} (#${player.id})</strong><br>
                        <strong>Likes:</strong> ${player.likes.join(', ')}<br>
                        <strong>Dislikes:</strong> ${player.dislikes.join(', ')}<br>
                        <strong>Objectives:</strong>
                        <ol>
                            ${player.objectives.map(obj => `<li>${obj}</li>`).join('')}
                        </ol>
                        <strong>Starting Clues:</strong>
                        <ul>
                            ${player.startingClues.map(clue => 
                                `<li>${clue.text} <span style="color: ${clue.isReal ? 'var(--accent-gold)' : 'var(--accent-crimson)'}">(${clue.isReal ? 'Real' : 'Fake'})</span></li>`
                            ).join('')}
                        </ul>
                    </div>
                `;
                div.appendChild(section);
            });

            // Hidden clues
            const hiddenSection = document.createElement('div');
            hiddenSection.className = 'objectives-list';
            hiddenSection.style.marginTop = '2rem';
            hiddenSection.innerHTML = `
                <div class="objective-item" style="border-left-color: var(--accent-gold);">
                    <strong>Hidden Clues (to be found during game):</strong>
                    <ul>
                        ${gameState.hiddenClues.map(clue => 
                            `<li>${clue.text} <span style="color: var(--accent-gold)">(Real)</span></li>`
                        ).join('')}
                    </ul>
                </div>
            `;
            div.appendChild(hiddenSection);

            document.getElementById('roleAssignmentPhase').classList.add('hidden');
            document.getElementById('objectivesPhase').classList.remove('hidden');
        }

        function startNightPhase() {
            document.getElementById('objectivesPhase').classList.add('hidden');
            document.getElementById('nightPhase').classList.remove('hidden');
            document.getElementById('nightRound').textContent = gameState.round;
            
            generateNightActions();
        }

        function generateNightActions() {
            const div = document.getElementById('nightActions');
            div.innerHTML = '';

            const alivePlayers = gameState.players.filter(p => p.alive);
            const murderer = gameState.players.find(p => p.role === "Murderer" && p.alive);
            const assassin = gameState.players.find(p => p.role === "Assassin" && p.alive);
            const spy = gameState.players.find(p => p.role === "Spy" && p.alive);
            const doctor = gameState.players.find(p => p.role === "Doctor" && p.alive);
            const detective = gameState.players.find(p => p.role === "Detective" && p.alive);
            const witch = gameState.players.find(p => p.role === "Witch" && p.alive);
            const vigilante = gameState.players.find(p => p.role === "Vigilante" && p.alive);

            // Check if this is a 7-player game (Murderer and Spy don't act Night 1)
            const is7PlayerGame = gameState.players.length === 7;
            const skipMurdererSpyNight1 = is7PlayerGame && gameState.round === 1;

            // Murderer action (skip Night 1 for 7-player games)
            if (murderer && !skipMurdererSpyNight1) {
                div.innerHTML += `
                    <div class="action-row">
                        <div class="action-label">Murderer kills:</div>
                        <select id="murdererTarget">
                            <option value="">No one</option>
                            ${alivePlayers.filter(p => p.id !== murderer.id).map(p => 
                                `<option value="${p.id}">${p.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
            } else if (murderer && skipMurdererSpyNight1) {
                div.innerHTML += `
                    <div class="feedback-item" style="margin-bottom: 1rem;">
                        <strong>Note:</strong> Murderer and Spy do not act on Night 1 in 7-player games.
                    </div>
                `;
            }

            // Assassin action (if hasn't used kill yet)
            if (assassin && !assassin.assassinKilled) {
                div.innerHTML += `
                    <div class="action-row">
                        <div class="action-label">Assassin (unblockable kill):</div>
                        <select id="assassinTarget">
                            <option value="">Don't use</option>
                            ${alivePlayers.filter(p => p.id !== assassin.id).map(p => 
                                `<option value="${p.id}">${p.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
            }

            // Spy action (skip Night 1 for 7-player games)
            if (spy && !skipMurdererSpyNight1) {
                div.innerHTML += `
                    <div class="action-row">
                        <div class="action-label">Spy investigates:</div>
                        <select id="spyTarget">
                            <option value="">No one</option>
                            ${alivePlayers.filter(p => p.id !== spy.id).map(p => 
                                `<option value="${p.id}">${p.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
            }

            // Witch action (if currently mimicking a night-action role)
            if (witch && gameState.witchCurrentMimic) {
                const mimicRole = gameState.witchCurrentMimic;
                if (["Doctor", "Detective", "Spy"].includes(mimicRole)) {
                    let label = "";
                    if (mimicRole === "Doctor") label = "Witch (as Doctor) saves:";
                    if (mimicRole === "Detective") label = "Witch (as Detective) investigates:";
                    if (mimicRole === "Spy") label = "Witch (as Spy) investigates:";

                    div.innerHTML += `
                        <div class="action-row">
                            <div class="action-label">${label}</div>
                            <select id="witchTarget">
                                <option value="">No one</option>
                                ${alivePlayers.filter(p => p.id !== witch.id).map(p => 
                                    `<option value="${p.id}">${p.name}</option>`
                                ).join('')}
                            </select>
                        </div>
                    `;
                }
            }

            // Doctor action
            if (doctor) {
                div.innerHTML += `
                    <div class="action-row">
                        <div class="action-label">Doctor saves:</div>
                        <select id="doctorTarget">
                            <option value="">No one</option>
                            ${alivePlayers.filter(p => 
                                p.id !== doctor.id && 
                                (!doctor.doctorLastSaved || p.id !== doctor.doctorLastSaved)
                            ).map(p => 
                                `<option value="${p.id}">${p.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
            }

            // Detective action
            if (detective) {
                div.innerHTML += `
                    <div class="action-row">
                        <div class="action-label">Detective investigates house of:</div>
                        <select id="detectiveTarget">
                            <option value="">No one</option>
                            ${alivePlayers.filter(p => p.id !== detective.id).map(p => 
                                `<option value="${p.id}">${p.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
            }

            // Vigilante action (1-shot)
            if (vigilante && !vigilante.vigilanteShot) {
                div.innerHTML += `
                    <div class="action-row">
                        <div class="action-label">Vigilante (1-shot kill):</div>
                        <select id="vigilanteTarget">
                            <option value="">Don't use</option>
                            ${alivePlayers.filter(p => p.id !== vigilante.id).map(p => 
                                `<option value="${p.id}">${p.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
            }
        }

        function resolveNightActions() {
            const murdererTargetId = document.getElementById('murdererTarget')?.value;
            const assassinTargetId = document.getElementById('assassinTarget')?.value;
            const spyTargetId = document.getElementById('spyTarget')?.value;
            const doctorTargetId = document.getElementById('doctorTarget')?.value;
            const detectiveTargetId = document.getElementById('detectiveTarget')?.value;
            const witchTargetId = document.getElementById('witchTarget')?.value;
            const vigilanteTargetId = document.getElementById('vigilanteTarget')?.value;

            const feedback = {};

            gameState.players.filter(p => p.alive).forEach(p => {
                feedback[p.id] = [];
            });

            const murderer = gameState.players.find(p => p.role === "Murderer" && p.alive);
            const assassin = gameState.players.find(p => p.role === "Assassin" && p.alive);
            const spy = gameState.players.find(p => p.role === "Spy" && p.alive);
            const doctor = gameState.players.find(p => p.role === "Doctor" && p.alive);
            const detective = gameState.players.find(p => p.role === "Detective" && p.alive);
            const witch = gameState.players.find(p => p.role === "Witch" && p.alive);
            const psychic = gameState.players.find(p => p.role === "Psychic" && p.alive);
            const medium = gameState.players.find(p => p.role === "Medium" && p.alive);
            const coroner = gameState.players.find(p => p.role === "Coroner" && p.alive);
            const vigilante = gameState.players.find(p => p.role === "Vigilante" && p.alive);

            const actions = {
                murdererTarget: murdererTargetId ? parseInt(murdererTargetId) : null,
                assassinTarget: assassinTargetId ? parseInt(assassinTargetId) : null,
                spyTarget: spyTargetId ? parseInt(spyTargetId) : null,
                doctorTarget: doctorTargetId ? parseInt(doctorTargetId) : null,
                detectiveTarget: detectiveTargetId ? parseInt(detectiveTargetId) : null,
                witchTarget: witchTargetId ? parseInt(witchTargetId) : null,
                vigilanteTarget: vigilanteTargetId ? parseInt(vigilanteTargetId) : null
            };

            // Resolve Vigilante kill first (they might die, affecting other actions)
            if (actions.vigilanteTarget && vigilante) {
                const target = gameState.players.find(p => p.id === actions.vigilanteTarget);
                vigilante.vigilanteShot = true;
                
                if (target.alignment === "Evil") {
                    // Vigilante shot Evil - Evil dies, Vigilante survives
                    target.alive = false;
                    feedback[vigilante.id] = [`You shot ${target.name}. They were Evil. You survived.`];
                    feedback[actions.vigilanteTarget] = [`You were shot by the Vigilante.`];
                    
                    gameState.deathLog.push({
                        round: gameState.round,
                        player: target.name,
                        cause: "Vigilante kill"
                    });

                    checkSuccession(target);
                } else {
                    // Vigilante shot Good - Vigilante dies, Good survives
                    vigilante.alive = false;
                    feedback[vigilante.id] = [`You shot ${target.name}. They were Good. You have died.`];
                    feedback[actions.vigilanteTarget] = [`The Vigilante tried to shoot you, but you are Good. They died instead.`];
                    
                    gameState.deathLog.push({
                        round: gameState.round,
                        player: vigilante.name,
                        cause: "Failed vigilante kill (shot Good)"
                    });

                    checkSuccession(vigilante);
                }
            }

            // Resolve Assassin kill (unblockable)
            if (actions.assassinTarget && assassin) {
                const target = gameState.players.find(p => p.id === actions.assassinTarget);
                target.alive = false;
                assassin.assassinKilled = true;
                feedback[actions.assassinTarget] = [`You were assassinated during the night (unblockable).`];
                
                gameState.deathLog.push({
                    round: gameState.round,
                    player: target.name,
                    cause: "Assassinated"
                });

                // Check succession
                checkSuccession(target);
            }

            // Resolve Murderer kill
            if (actions.murdererTarget && murderer) {
                const target = gameState.players.find(p => p.id === actions.murdererTarget);
                
                // Check if Doctor saved
                const doctorSaved = actions.doctorTarget === actions.murdererTarget;
                
                // Check if Witch mimicking Doctor saved
                const witchSaved = witch && gameState.witchCurrentMimic === "Doctor" && 
                                   actions.witchTarget === actions.murdererTarget;
                
                if (!doctorSaved && !witchSaved && target.alive) {
                    target.alive = false;
                    feedback[actions.murdererTarget] = [`You were murdered during the night.`];
                    
                    gameState.deathLog.push({
                        round: gameState.round,
                        player: target.name,
                        cause: "Murdered"
                    });

                    // Check succession
                    checkSuccession(target);
                }
            }

            // Update Doctor's last saved
            if (doctor && actions.doctorTarget) {
                const doctorTarget = gameState.players.find(p => p.id === actions.doctorTarget);
                doctor.doctorLastSaved = actions.doctorTarget;
                
                if (actions.murdererTarget === actions.doctorTarget) {
                    feedback[doctor.id].push(`You saved ${doctorTarget.name}'s life last night.`);
                    gameState.roleBonuses[doctor.id].doctorSaved = true; // Track for bonus
                } else {
                    feedback[doctor.id].push(`${doctorTarget.name} did not require assistance last night.`);
                }
            }

            // Witch Doctor mimicking feedback
            if (witch && gameState.witchCurrentMimic === "Doctor" && actions.witchTarget) {
                const witchTarget = gameState.players.find(p => p.id === actions.witchTarget);
                if (actions.murdererTarget === actions.witchTarget) {
                    feedback[witch.id].push(`You (as Doctor) saved ${witchTarget.name}'s life last night.`);
                } else {
                    feedback[witch.id].push(`${witchTarget.name} (as Doctor) did not require assistance last night.`);
                }
            }

            // Spy feedback
            if (spy && actions.spyTarget) {
                const spyTarget = gameState.players.find(p => p.id === actions.spyTarget);
                feedback[spy.id].push(`${spyTarget.name} is a ${spyTarget.role}.`);
                
                // Check if Spy found someone leaving their house (Doctor or Detective)
                const targetLeftHouse = (
                    (doctor && doctor.id === actions.spyTarget && actions.doctorTarget !== null) ||
                    (detective && detective.id === actions.spyTarget && actions.detectiveTarget !== null)
                );
                
                if (targetLeftHouse) {
                    gameState.roleBonuses[spy.id].spyFoundLeaving = true;
                }
            }

            // Witch Spy mimicking feedback
            if (witch && gameState.witchCurrentMimic === "Spy" && actions.witchTarget) {
                const witchTarget = gameState.players.find(p => p.id === actions.witchTarget);
                feedback[witch.id].push(`${witchTarget.name} (as Spy) is a ${witchTarget.role}.`);
            }

            // Detective feedback
            if (detective && actions.detectiveTarget) {
                const detectiveTarget = gameState.players.find(p => p.id === actions.detectiveTarget);
                
                const targetLeftHouse = (
                    (murderer && murderer.id === actions.detectiveTarget && actions.murdererTarget !== null) ||
                    (spy && spy.id === actions.detectiveTarget && actions.spyTarget !== null) ||
                    (doctor && doctor.id === actions.detectiveTarget && actions.doctorTarget !== null) ||
                    (assassin && assassin.id === actions.detectiveTarget && actions.assassinTarget !== null)
                );
                
                const visitors = [];
                if (actions.murdererTarget === actions.detectiveTarget && murderer) {
                    visitors.push(murderer.name);
                    gameState.roleBonuses[detective.id].detectiveCrime = true; // Murderer visited house
                }
                if (actions.assassinTarget === actions.detectiveTarget && assassin) {
                    visitors.push(assassin.name);
                    gameState.roleBonuses[detective.id].detectiveCrime = true; // Assassin visited house
                }
                if (actions.spyTarget === actions.detectiveTarget && spy) visitors.push(spy.name);
                if (actions.doctorTarget === actions.detectiveTarget && doctor) visitors.push(doctor.name);
                if (actions.witchTarget === actions.detectiveTarget && witch) visitors.push(`${witch.name} (as ${gameState.witchCurrentMimic})`);
                
                // Check if Detective investigated Murderer or Spy's house and they left
                if ((murderer && murderer.id === actions.detectiveTarget && actions.murdererTarget !== null) ||
                    (spy && spy.id === actions.detectiveTarget && actions.spyTarget !== null)) {
                    gameState.roleBonuses[detective.id].detectiveCrime = true;
                }
                
                if (visitors.length > 0) {
                    feedback[detective.id].push(`${detectiveTarget.name} was visited by ${visitors.join(', ')} last night.`);
                } else if (targetLeftHouse) {
                    feedback[detective.id].push(`${detectiveTarget.name} left their house last night.`);
                } else {
                    feedback[detective.id].push(`There was no activity at ${detectiveTarget.name}'s house last night.`);
                }
            }

            // Witch Detective mimicking feedback
            if (witch && gameState.witchCurrentMimic === "Detective" && actions.witchTarget) {
                const witchDetectiveTarget = gameState.players.find(p => p.id === actions.witchTarget);
                
                const targetLeftHouse = (
                    (murderer && murderer.id === actions.witchTarget && actions.murdererTarget !== null) ||
                    (spy && spy.id === actions.witchTarget && actions.spyTarget !== null) ||
                    (doctor && doctor.id === actions.witchTarget && actions.doctorTarget !== null) ||
                    (assassin && assassin.id === actions.witchTarget && actions.assassinTarget !== null)
                );
                
                const visitors = [];
                if (actions.murdererTarget === actions.witchTarget && murderer) visitors.push(murderer.name);
                if (actions.assassinTarget === actions.witchTarget && assassin) visitors.push(assassin.name);
                if (actions.spyTarget === actions.witchTarget && spy) visitors.push(spy.name);
                if (actions.doctorTarget === actions.witchTarget && doctor) visitors.push(doctor.name);
                
                if (visitors.length > 0) {
                    feedback[witch.id].push(`${witchDetectiveTarget.name} (as Detective) was visited by ${visitors.join(', ')} last night.`);
                } else if (targetLeftHouse) {
                    feedback[witch.id].push(`${witchDetectiveTarget.name} (as Detective) left their house last night.`);
                } else {
                    feedback[witch.id].push(`There was no activity at ${witchDetectiveTarget.name}'s house (as Detective) last night.`);
                }
            }

            // Psychic feedback
            if (psychic && gameState.hiddenClues.length > gameState.psychicCluesGiven.length) {
                const availableClues = gameState.hiddenClues.filter((clue, idx) => 
                    !gameState.psychicCluesGiven.includes(idx)
                );
                if (availableClues.length > 0) {
                    const randomClue = availableClues[Math.floor(Math.random() * availableClues.length)];
                    const clueIdx = gameState.hiddenClues.indexOf(randomClue);
                    gameState.psychicCluesGiven.push(clueIdx);
                    feedback[psychic.id].push(`Psychic vision: ${randomClue.text}`);
                }
            }

            // Witch Psychic mimicking
            if (witch && gameState.witchCurrentMimic === "Psychic" && gameState.hiddenClues.length > 0) {
                const randomClue = gameState.hiddenClues[Math.floor(Math.random() * gameState.hiddenClues.length)];
                feedback[witch.id].push(`Psychic vision (as Psychic): ${randomClue.text}`);
            }

            // Medium feedback
            if (medium) {
                const deadPlayers = gameState.players.filter(p => !p.alive);
                if (deadPlayers.length > 0) {
                    feedback[medium.id].push(`Select a dead person to learn their role during this night feedback.`);
                }
            }

            // Witch Medium mimicking
            if (witch && gameState.witchCurrentMimic === "Medium") {
                const deadPlayers = gameState.players.filter(p => !p.alive);
                if (deadPlayers.length > 0) {
                    feedback[witch.id].push(`Select a dead person (as Medium) to learn their role during this night feedback.`);
                }
            }

            // Coroner feedback
            if (coroner && gameState.deathLog.length > 0) {
                const deathReport = gameState.deathLog.map(d => 
                    `Round ${d.round}: ${d.player} - ${d.cause}`
                ).join('<br>');
                feedback[coroner.id].push(`Death log:<br>${deathReport}`);
            }

            // Witch Coroner mimicking
            if (witch && gameState.witchCurrentMimic === "Coroner" && gameState.deathLog.length > 0) {
                const deathReport = gameState.deathLog.map(d => 
                    `Round ${d.round}: ${d.player} - ${d.cause}`
                ).join('<br>');
                feedback[witch.id].push(`Death log (as Coroner):<br>${deathReport}`);
            }

            displayNightFeedback(feedback);
        }

        function checkSuccession(deadPlayer) {
            // Check if we need succession
            const murderers = gameState.players.filter(p => 
                (p.originalRole === "Murderer" || p.originalRole === "Assassin") && p.alive
            );
            
            // If no murderers left alive, start succession
            if (murderers.length === 0) {
                // Succession order: Assassin → Spy → Witch
                const successors = ["Assassin", "Spy", "Witch"];
                
                for (const role of successors) {
                    const successor = gameState.players.find(p => 
                        p.originalRole === role && p.alive && p.role !== "Murderer"
                    );
                    if (successor) {
                        successor.role = "Murderer";
                        return;
                    }
                }
            }
            // For 14-16 players: If only Murderer dies (Assassin still alive), start succession
            else if (deadPlayer.role === "Murderer" && gameState.players.find(p => p.originalRole === "Assassin" && p.alive)) {
                const successors = ["Assassin", "Spy", "Witch"];
                
                for (const role of successors) {
                    const successor = gameState.players.find(p => 
                        p.originalRole === role && p.alive && p.role !== "Murderer"
                    );
                    if (successor) {
                        successor.role = "Murderer";
                        return;
                    }
                }
            }
        }

        function displayNightFeedback(feedback) {
            const div = document.getElementById('nightFeedback');
            div.innerHTML = '';

            // Add Witch role selection interface
            const witch = gameState.players.find(p => p.role === "Witch" && p.alive);
            if (witch) {
                const witchSection = document.createElement('div');
                witchSection.className = 'feedback-section';
                witchSection.style.backgroundColor = 'var(--accent-crimson)';
                witchSection.style.borderColor = 'var(--accent-gold)';
                
                const allRoles = ["Doctor", "Detective", "Judge", "Mayor", "Psychic", "Medium", "Coroner", "Spy"];
                const availableRoles = allRoles.filter(role => 
                    !gameState.witchMimicHistory.includes(role)
                );
                
                witchSection.innerHTML = `
                    <h3>Witch: Select Role to Mimic Next</h3>
                    <div class="feedback-item">
                        <p>Choose which role you want to mimic for the next day+night cycle:</p>
                        <select id="witchMimicSelect" style="margin-top: 1rem;">
                            <option value="">Don't mimic anyone</option>
                            ${availableRoles.map(role => 
                                `<option value="${role}">${role}</option>`
                            ).join('')}
                        </select>
                        <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
                            Already mimicked: ${gameState.witchMimicHistory.join(', ') || 'None'}
                        </p>
                    </div>
                `;
                div.appendChild(witchSection);
            }

            gameState.players.forEach(player => {
                if (player.alive || feedback[player.id]?.length > 0) {
                    const section = document.createElement('div');
                    section.className = 'feedback-section';
                    
                    const items = feedback[player.id] || ['No special information.'];
                    
                    section.innerHTML = `
                        <h3>${player.name} (#${player.id}) - ${player.role}</h3>
                        ${items.map(item => `<div class="feedback-item">${item}</div>`).join('')}
                    `;
                    div.appendChild(section);
                }
            });

            document.getElementById('nightPhase').classList.add('hidden');
            document.getElementById('nightFeedbackPhase').classList.remove('hidden');
            updateSidebar();
        }

        function startDayPhase() {
            // Update Witch mimic selection
            const witchMimicSelect = document.getElementById('witchMimicSelect');
            const witch = gameState.players.find(p => p.role === "Witch" && p.alive);
            
            if (witchMimicSelect && witch) {
                const selectedMimic = witchMimicSelect.value;
                if (selectedMimic) {
                    gameState.witchCurrentMimic = selectedMimic;
                    gameState.witchMimicHistory.push(selectedMimic);
                    gameState.witchMimicStartRound = gameState.round;
                } else {
                    gameState.witchCurrentMimic = null;
                }
            }

            // Restore mayor voting power if penalized
            if (gameState.mayorPenalty) {
                const mayor = gameState.players.find(p => p.role === "Mayor" && p.alive);
                if (mayor) {
                    mayor.votePower = 2;
                    gameState.mayorPenalty = false;
                }
            }
            
            document.getElementById('nightFeedbackPhase').classList.add('hidden');
            document.getElementById('dayPhase').classList.remove('hidden');
            document.getElementById('dayRound').textContent = gameState.round;
            
            generateVotingSection();
        }

        function generateVotingSection() {
            const div = document.getElementById('votingSection');
            div.innerHTML = '';

            const alivePlayers = gameState.players.filter(p => p.alive);
            const judge = gameState.players.find(p => p.role === "Judge" && p.alive);
            const witch = gameState.players.find(p => p.role === "Witch" && p.alive);

            const voteGrid = document.createElement('div');
            voteGrid.className = 'vote-grid';

            alivePlayers.forEach(player => {
                const voteItem = document.createElement('div');
                voteItem.className = 'vote-item';
                
                let votePower = player.votePower;
                // Check if Witch is mimicking Mayor
                if (witch && gameState.witchCurrentMimic === "Mayor" && player.id === witch.id) {
                    votePower = 2;
                }
                
                const votePowerLabel = votePower > 1 ? ` (${votePower} votes)` : '';
                
                voteItem.innerHTML = `
                    <label>${player.name}${votePowerLabel}</label>
                    <select id="vote-${player.id}">
                        <option value="skip">Skip</option>
                        ${alivePlayers.map(p => 
                            `<option value="${p.id}">${p.name}</option>`
                        ).join('')}
                    </select>
                `;
                voteGrid.appendChild(voteItem);
            });

            div.appendChild(voteGrid);

            // Judge save option
            if (judge && judge.judgeUses > 0) {
                const judgeSection = document.createElement('div');
                judgeSection.style.marginTop = '1.5rem';
                judgeSection.innerHTML = `
                    <div class="action-row">
                        <div class="action-label">Judge saves (${judge.judgeUses} uses left):</div>
                        <select id="judgeSave">
                            <option value="">No one</option>
                            ${alivePlayers.filter(p => !judge.judgeUsedOn.includes(p.id)).map(p => 
                                `<option value="${p.id}">${p.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
                div.appendChild(judgeSection);
            }

            // Witch mimicking Judge option
            if (witch && gameState.witchCurrentMimic === "Judge") {
                const witchJudgeSection = document.createElement('div');
                witchJudgeSection.style.marginTop = '1.5rem';
                witchJudgeSection.innerHTML = `
                    <div class="action-row">
                        <div class="action-label">Witch (as Judge) saves:</div>
                        <select id="witchJudgeSave">
                            <option value="">No one</option>
                            ${alivePlayers.map(p => 
                                `<option value="${p.id}">${p.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
                div.appendChild(witchJudgeSection);
            }
        }

        function resolveVotes() {
            const alivePlayers = gameState.players.filter(p => p.alive);
            const voteCounts = {};
            let skipVotes = 0;
            const mayorVotes = {};

            const witch = gameState.players.find(p => p.role === "Witch" && p.alive);

            // Count votes
            alivePlayers.forEach(player => {
                const voteSelect = document.getElementById(`vote-${player.id}`);
                const vote = voteSelect.value;
                mayorVotes[player.id] = vote;
                
                let votePower = player.votePower;
                // Witch mimicking Mayor gets double vote
                if (witch && gameState.witchCurrentMimic === "Mayor" && player.id === witch.id) {
                    votePower = 2;
                }
                
                if (vote === 'skip') {
                    skipVotes += votePower;
                } else {
                    const targetId = parseInt(vote);
                    voteCounts[targetId] = (voteCounts[targetId] || 0) + votePower;
                }
            });

            // Check for skip
            if (skipVotes >= Math.ceil(alivePlayers.length / 2) + 1) {
                displayVoteResults(voteCounts, null, 'Vote skipped by majority', null);
                return;
            }

            // Find highest vote count
            const maxVotes = Math.max(...Object.values(voteCounts));
            const candidates = Object.keys(voteCounts).filter(id => voteCounts[id] === maxVotes).map(id => parseInt(id));

            // Check judge save
            const judgeSaveId = document.getElementById('judgeSave')?.value;
            const witchJudgeSaveId = document.getElementById('witchJudgeSave')?.value;
            const judge = gameState.players.find(p => p.role === "Judge" && p.alive);
            
            // Judge can save
            if (judgeSaveId && candidates.includes(parseInt(judgeSaveId))) {
                const savedPlayer = gameState.players.find(p => p.id === parseInt(judgeSaveId));
                judge.judgeUses--;
                judge.judgeUsedOn.push(parseInt(judgeSaveId));
                
                // Track if Judge saved an innocent (Good) player
                if (savedPlayer.alignment === "Good") {
                    gameState.roleBonuses[judge.id].judgeSavedInnocent = true;
                }
                
                displayVoteResults(voteCounts, null, `Judge saved ${savedPlayer.name}`, null);
                return;
            }

            // Witch mimicking Judge can save
            if (witchJudgeSaveId && candidates.includes(parseInt(witchJudgeSaveId))) {
                const savedPlayer = gameState.players.find(p => p.id === parseInt(witchJudgeSaveId));
                displayVoteResults(voteCounts, null, `Witch (as Judge) saved ${savedPlayer.name}`, null);
                return;
            }

            // Handle ties
            if (candidates.length > 1) {
                displayVoteResults(voteCounts, null, `Tie between: ${candidates.map(id => gameState.players.find(p => p.id === id).name).join(', ')} - No elimination`, null);
                return;
            }

            // Eliminate player
            const eliminatedId = candidates[0];
            const eliminated = gameState.players.find(p => p.id === eliminatedId);
            eliminated.alive = false;

            gameState.deathLog.push({
                round: gameState.round,
                player: eliminated.name,
                cause: "Voted out"
            });

            // Check succession
            checkSuccession(eliminated);

            // Mayor feedback and penalty
            const mayor = gameState.players.find(p => p.role === "Mayor" && p.alive);
            let mayorFeedback = null;
            
            if (mayor) {
                const mayorVote = mayorVotes[mayor.id];
                if (mayorVote !== 'skip' && parseInt(mayorVote) === eliminatedId) {
                    mayorFeedback = {
                        alignment: eliminated.alignment,
                        penalized: eliminated.alignment === "Good"
                    };
                    
                    if (eliminated.alignment === "Good") {
                        mayor.votePower = 1;
                        gameState.mayorPenalty = true;
                    }
                }
            }

            // Witch mimicking Mayor feedback
            if (witch && gameState.witchCurrentMimic === "Mayor") {
                const witchVote = mayorVotes[witch.id];
                if (witchVote !== 'skip' && parseInt(witchVote) === eliminatedId) {
                    if (!mayorFeedback) mayorFeedback = { alignment: eliminated.alignment, penalized: false, witchMayor: true };
                }
            }

            displayVoteResults(voteCounts, eliminated, null, mayorFeedback);
            updateSidebar();
        }

        function displayVoteResults(voteCounts, eliminated, message = null, mayorFeedback = null) {
            const div = document.getElementById('voteResults');
            div.innerHTML = '';

            // Show vote counts
            const resultsDiv = document.createElement('div');
            resultsDiv.className = 'vote-results';
            resultsDiv.innerHTML = '<h3>Vote Totals</h3>';
            
            // Judge sees vote totals
            const judge = gameState.players.find(p => p.role === "Judge" && p.alive);
            const witch = gameState.players.find(p => p.role === "Witch" && p.alive);
            
            Object.entries(voteCounts).forEach(([id, count]) => {
                const player = gameState.players.find(p => p.id === parseInt(id));
                const item = document.createElement('div');
                item.className = 'vote-result-item';
                item.innerHTML = `
                    <span>${player.name}</span>
                    <span>${count} vote${count !== 1 ? 's' : ''}</span>
                `;
                resultsDiv.appendChild(item);
            });
            
            div.appendChild(resultsDiv);

            // Show result
            const resultMessage = document.createElement('div');
            resultMessage.className = message || !eliminated ? 'error' : 'success';
            resultMessage.style.marginTop = '1rem';
            resultMessage.style.fontSize = '1.3rem';
            
            if (message) {
                resultMessage.textContent = message;
            } else if (eliminated) {
                resultMessage.innerHTML = `
                    <strong>${eliminated.name}</strong> has been eliminated!<br>
                    Role: ${eliminated.role}<br>
                    Alignment: <span class="player-status ${eliminated.alignment.toLowerCase()}">${eliminated.alignment}</span>
                `;
            }
            
            div.appendChild(resultMessage);

            // Judge/Witch feedback
            if (judge || (witch && gameState.witchCurrentMimic === "Judge")) {
                const judgeDiv = document.createElement('div');
                judgeDiv.className = 'feedback-section';
                judgeDiv.style.marginTop = '1.5rem';
                judgeDiv.innerHTML = `
                    <h3>${judge ? 'Judge' : 'Witch (as Judge)'} Feedback</h3>
                    <div class="feedback-item">
                        Vote totals are shown above.
                    </div>
                `;
                div.appendChild(judgeDiv);
            }

            // Mayor feedback
            if (mayorFeedback) {
                const mayorDiv = document.createElement('div');
                mayorDiv.className = 'feedback-section';
                mayorDiv.style.marginTop = '1.5rem';
                mayorDiv.innerHTML = `
                    <h3>${mayorFeedback.witchMayor ? 'Witch (as Mayor)' : 'Mayor'} Feedback</h3>
                    <div class="feedback-item">
                        The player you voted for was eliminated.<br>
                        Their alignment: <span class="player-status ${mayorFeedback.alignment.toLowerCase()}">${mayorFeedback.alignment}</span><br>
                        ${mayorFeedback.penalized ? '<strong style="color: var(--accent-crimson);">Your voting power is halved for the next round (1 vote instead of 2).</strong>' : '<strong style="color: var(--accent-gold);">Good call! Your voting power remains at 2.</strong>'}
                    </div>
                `;
                div.appendChild(mayorDiv);
            }

            document.getElementById('dayPhase').classList.add('hidden');
            document.getElementById('voteResultsPhase').classList.remove('hidden');
        }

        function checkWinCondition() {
            const aliveGood = gameState.players.filter(p => p.alive && p.alignment === "Good").length;
            const aliveEvil = gameState.players.filter(p => p.alive && p.alignment === "Evil").length;

            if (aliveEvil === 0) {
                endGame("Good");
            } else if (aliveEvil >= aliveGood) {
                endGame("Evil");
            } else {
                gameState.round++;
                document.getElementById('voteResultsPhase').classList.add('hidden');
                startNightPhase();
            }
        }

        function endGame(winner) {
            const div = document.getElementById('gameEndMessage');
            div.innerHTML = `
                <div class="success" style="font-size: 1.5rem; text-align: center; padding: 2rem;">
                    <h2 style="color: var(--accent-gold); margin-bottom: 1rem;">${winner} Team Wins!</h2>
                    <p>Survivors:</p>
                    ${gameState.players.filter(p => p.alive).map(p => `
                        <div style="margin: 0.5rem 0;">
                            ${p.name} - ${p.role} 
                            <span class="player-status ${p.alignment.toLowerCase()}">${p.alignment}</span>
                        </div>
                    `).join('')}
                </div>
            `;

            document.getElementById('voteResultsPhase').classList.add('hidden');
            document.getElementById('gameEndPhase').classList.remove('hidden');
        }

        function showPointsEntry() {
            const div = document.getElementById('pointsEntry');
            div.innerHTML = '';

            const winner = gameState.players.filter(p => p.alive && p.alignment === "Evil").length === 0 ? "Good" : "Evil";

            gameState.players.forEach(player => {
                const section = document.createElement('div');
                section.className = 'points-section';
                
                const survived = player.alive ? 1 : 0;
                const winning = (player.alive && player.alignment === winner) ? (winner === "Good" ? 2 : 3) : 0;
                
                // Calculate role bonus (max +1, don't stack)
                let roleBonus = 0;
                let roleBonusReason = '';
                const bonuses = gameState.roleBonuses[player.id] || {};
                
                // Civilian: win + survive
                if (player.role === "Civilian" && player.alive && player.alignment === winner) {
                    roleBonus = 1;
                    roleBonusReason = 'Civilian (won and survived)';
                }
                
                // Murderer: win with Murderer and Spy both alive (or just win if only 1 evil role)
                if ((player.role === "Murderer" || player.originalRole === "Murderer") && player.alive && winner === "Evil") {
                    const evilRoles = gameState.players.filter(p => p.alignment === "Evil");
                    if (evilRoles.length === 1) {
                        // Only 1 evil role total
                        roleBonus = 1;
                        roleBonusReason = 'Murderer (won as only evil)';
                    } else {
                        // Check if both Murderer and Spy are alive
                        const murdererAlive = gameState.players.find(p => p.originalRole === "Murderer" && p.alive);
                        const spyAlive = gameState.players.find(p => p.originalRole === "Spy" && p.alive);
                        if (murdererAlive && spyAlive) {
                            roleBonus = 1;
                            roleBonusReason = 'Murderer (won with Spy both alive)';
                        }
                    }
                }
                
                // Spy: same as Murderer
                if ((player.role === "Spy" || player.originalRole === "Spy") && player.alive && winner === "Evil") {
                    const evilRoles = gameState.players.filter(p => p.alignment === "Evil");
                    if (evilRoles.length === 1) {
                        roleBonus = 1;
                        roleBonusReason = 'Spy (won as only evil)';
                    } else {
                        const murdererAlive = gameState.players.find(p => p.originalRole === "Murderer" && p.alive);
                        const spyAlive = gameState.players.find(p => p.originalRole === "Spy" && p.alive);
                        if (murdererAlive && spyAlive) {
                            roleBonus = 1;
                            roleBonusReason = 'Spy (won with Murderer both alive)';
                        }
                    }
                }
                
                // Doctor: saved someone
                if (player.role === "Doctor" && bonuses.doctorSaved) {
                    roleBonus = 1;
                    roleBonusReason = 'Doctor (saved someone)';
                }
                
                // Detective: investigated crime or found Murderer/Spy leaving
                if (player.role === "Detective" && bonuses.detectiveCrime) {
                    roleBonus = 1;
                    roleBonusReason = 'Detective (investigated crime)';
                }
                
                // Spy: found someone leaving house
                if ((player.role === "Spy" || player.originalRole === "Spy") && bonuses.spyFoundLeaving && roleBonus === 0) {
                    roleBonus = 1;
                    roleBonusReason = 'Spy (found someone leaving)';
                }
                
                // Judge: saved innocent
                if (player.role === "Judge" && bonuses.judgeSavedInnocent) {
                    roleBonus = 1;
                    roleBonusReason = 'Judge (saved innocent)';
                }
                
                section.innerHTML = `
                    <h3>${player.name} - ${player.role}${player.originalRole !== player.role ? ` (was ${player.originalRole})` : ''}</h3>
                    <div style="margin-bottom: 1rem;">
                        <strong>Automatic Points:</strong><br>
                        Survived: ${survived} pt${survived !== 1 ? 's' : ''}<br>
                        Winning: ${winning} pts<br>
                        ${roleBonus > 0 ? `Role Bonus: ${roleBonus} pt (${roleBonusReason})<br>` : ''}
                    </div>
                    <div class="points-input">
                        <label>Clues collected:</label>
                        <input type="number" id="clues-${player.id}" min="0" value="0">
                    </div>
                    <div style="margin-top: 1rem;">
                        <strong>Objective Completion:</strong><br>
                        <div class="points-input">
                            <label>Objective 2 answer (who they found):</label>
                            <select id="obj2-${player.id}">
                                <option value="">Not completed</option>
                                ${gameState.players.map(p => 
                                    `<option value="${p.id}">${p.name}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="points-input">
                            <label>Objective 3 answer (who they found):</label>
                            <select id="obj3-${player.id}">
                                <option value="">Not completed</option>
                                ${gameState.players.map(p => 
                                    `<option value="${p.id}">${p.name}</option>`
                                ).join('')}
                            </select>
                        </div>
                    </div>
                    <div style="margin-top: 0.5rem; font-weight: bold; color: var(--accent-gold);">
                        Subtotal (excluding objectives): ${survived + winning + roleBonus} pts
                    </div>
                `;
                div.appendChild(section);
            });

            document.getElementById('gameEndPhase').classList.add('hidden');
            document.getElementById('pointsEntryPhase').classList.remove('hidden');
        }

        function calculateFinalScores() {
            const winner = gameState.players.filter(p => p.alive).length > 0 && 
                          gameState.players.filter(p => p.alive && p.alignment === "Evil").length === 0 
                          ? "Good" : "Evil";

            // Track who shared correct info (for objective 1 completion)
            const sharedCorrectInfo = new Set();

            gameState.players.forEach(player => {
                const clues = parseInt(document.getElementById(`clues-${player.id}`).value) || 0;
                const obj2Answer = document.getElementById(`obj2-${player.id}`).value;
                const obj3Answer = document.getElementById(`obj3-${player.id}`).value;
                
                let points = 0;
                
                // Clues (+1 per clue)
                points += clues;
                
                // Survival (+1)
                if (player.alive) points += 1;
                
                // Winning
                if (player.alive && player.alignment === winner) {
                    points += winner === "Good" ? 2 : 3;
                }
                
                // Role bonus (max +1, don't stack)
                let roleBonus = 0;
                const bonuses = gameState.roleBonuses[player.id] || {};
                
                // Civilian: win + survive
                if (player.role === "Civilian" && player.alive && player.alignment === winner) {
                    roleBonus = 1;
                }
                
                // Murderer/Spy: win with both alive (or just win if only 1 evil)
                if ((player.role === "Murderer" || player.originalRole === "Murderer" || 
                     player.role === "Spy" || player.originalRole === "Spy") && 
                    player.alive && winner === "Evil") {
                    const evilRoles = gameState.players.filter(p => p.alignment === "Evil");
                    if (evilRoles.length === 1) {
                        roleBonus = 1;
                    } else {
                        const murdererAlive = gameState.players.find(p => p.originalRole === "Murderer" && p.alive);
                        const spyAlive = gameState.players.find(p => p.originalRole === "Spy" && p.alive);
                        if (murdererAlive && spyAlive) {
                            roleBonus = 1;
                        }
                    }
                }
                
                // Doctor: saved someone
                if (player.role === "Doctor" && bonuses.doctorSaved) {
                    roleBonus = 1;
                }
                
                // Detective: investigated crime
                if (player.role === "Detective" && bonuses.detectiveCrime) {
                    roleBonus = 1;
                }
                
                // Spy: found someone leaving (only if not already getting Murderer/Spy bonus)
                if ((player.role === "Spy" || player.originalRole === "Spy") && bonuses.spyFoundLeaving && roleBonus === 0) {
                    roleBonus = 1;
                }
                
                // Judge: saved innocent
                if (player.role === "Judge" && bonuses.judgeSavedInnocent) {
                    roleBonus = 1;
                }
                
                points += roleBonus;
                
                // Objectives (1/3 point each)
                let objectivesCompleted = 0;
                
                // Objective 2 validation
                if (obj2Answer) {
                    const obj2Text = player.objectives[1];
                    const answeredPlayer = gameState.players.find(p => p.id === parseInt(obj2Answer));
                    
                    if (obj2Text.includes("likes")) {
                        const preference = obj2Text.match(/likes (.+)\./)[1];
                        if (answeredPlayer.likes.includes(preference)) {
                            objectivesCompleted++;
                            sharedCorrectInfo.add(answeredPlayer.id);
                        }
                    } else if (obj2Text.includes("dislikes")) {
                        const preference = obj2Text.match(/dislikes (.+)\./)[1];
                        if (answeredPlayer.dislikes.includes(preference)) {
                            objectivesCompleted++;
                            sharedCorrectInfo.add(answeredPlayer.id);
                        }
                    }
                }
                
                // Objective 3 validation
                if (obj3Answer) {
                    const obj3Text = player.objectives[2];
                    const answeredPlayer = gameState.players.find(p => p.id === parseInt(obj3Answer));
                    
                    if (obj3Text.includes("likes")) {
                        const preference = obj3Text.match(/likes (.+)\./)[1];
                        if (answeredPlayer.likes.includes(preference)) {
                            objectivesCompleted++;
                            sharedCorrectInfo.add(answeredPlayer.id);
                        }
                    } else if (obj3Text.includes("dislikes")) {
                        const preference = obj3Text.match(/dislikes (.+)\./)[1];
                        if (answeredPlayer.dislikes.includes(preference)) {
                            objectivesCompleted++;
                            sharedCorrectInfo.add(answeredPlayer.id);
                        }
                    }
                }
                
                points += objectivesCompleted * (1/3);
                
                player.objectivesCompleted = objectivesCompleted;
                
                if (!gameState.cumulativeScores[player.id]) {
                    gameState.cumulativeScores[player.id] = {
                        name: player.name,
                        points: 0
                    };
                }
                
                player.tempPoints = points;
            });

            // Add objective 1 points (sharing info)
            gameState.players.forEach(player => {
                let points = player.tempPoints;
                
                if (sharedCorrectInfo.has(player.id)) {
                    points += 1/3;
                }
                
                gameState.cumulativeScores[player.id].points += points;
            });

            gameState.gamesPlayed++;
            displayLeaderboard();
        }

        function displayLeaderboard() {
            const scores = Object.values(gameState.cumulativeScores)
                .sort((a, b) => b.points - a.points);

            const podium = document.getElementById('podium');
            podium.innerHTML = '';

            const medals = ['🥇', '🥈', '🥉'];
            const classes = ['first', 'second', 'third'];

            for (let i = 0; i < Math.min(3, scores.length); i++) {
                const place = document.createElement('div');
                place.className = `podium-place ${classes[i]}`;
                place.innerHTML = `
                    <div class="medal">${medals[i]}</div>
                    <h3 style="color: var(--accent-gold); margin-bottom: 0.5rem;">${scores[i].name}</h3>
                    <div style="font-size: 2rem; font-weight: bold;">${scores[i].points.toFixed(2)} pts</div>
                `;
                podium.appendChild(place);
            }

            const fullLeaderboard = document.getElementById('fullLeaderboard');
            fullLeaderboard.innerHTML = '<h3 style="margin: 2rem 0 1rem; text-align: center;">Full Standings</h3>';
            
            scores.forEach((score, idx) => {
                const item = document.createElement('div');
                item.className = 'vote-result-item';
                item.innerHTML = `
                    <span>${idx + 1}. ${score.name}</span>
                    <span>${score.points.toFixed(2)} points</span>
                `;
                fullLeaderboard.appendChild(item);
            });

            document.getElementById('pointsEntryPhase').classList.add('hidden');
            document.getElementById('leaderboardPhase').classList.remove('hidden');
        }

        function playAgain() {
            gameState.round = 1;
            gameState.mayorPenalty = false;
            gameState.selectedCharacters = [];
            gameState.players = [];
            gameState.hiddenClues = [];
            gameState.deathLog = [];
            gameState.witchMimicHistory = [];
            gameState.witchCurrentMimic = null;
            gameState.witchMimicStartRound = null;
            gameState.assassinUsedKill = false;
            gameState.vigilanteUsedKill = false;
            gameState.psychicCluesGiven = [];
            gameState.roleBonuses = {};

            document.querySelectorAll('[id$="Phase"]').forEach(el => el.classList.add('hidden'));
            document.getElementById('setupPhase').classList.remove('hidden');
            document.querySelectorAll('#characterGrid input').forEach(cb => cb.checked = false);
            document.getElementById('sidebar').classList.add('hidden');
        }

        function wipeData() {
            if (confirm('Are you sure you want to wipe all data? This cannot be undone.')) {
                gameState = {
                    selectedCharacters: [],
                    players: [],
                    round: 1,
                    mayorPenalty: false,
                    cumulativeScores: {},
                    gamesPlayed: 0,
                    hiddenClues: [],
                    deathLog: [],
                    witchMimicHistory: [],
                    witchCurrentMimic: null,
                    witchMimicStartRound: null,
                    assassinUsedKill: false,
                    vigilanteUsedKill: false,
                    psychicCluesGiven: [],
                    roleBonuses: {}
                };
                
                playAgain();
            }
        }

        // Initialize on load
        initCharacterSelection();
    </script>
</body>
</html>